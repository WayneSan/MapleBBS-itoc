µo«H¤H: amaki.bbs@luna.twbbs.org (¥©§J¤O¦Ï) ¬ÝªO: plan
¼Ð  ÃD: [¥\¯à]¬ÝªOºëµØ°Ï±Æ¦æº]
µo«H¯¸: ¤ë¤U©]·Q (2004/01/02 Fri 22:58:57)                Updated: 2004/01/02

  Å¥»¡¤£¤Ö¯¸¥x¦³³oªF¦è¡A¼g¼g·í·s¦~Â§ª«§a¡C

  ¯¸ªø¥ý¦bAnnounce¸Ì·s¼W¸ê®Æ¡AÀÉ¦W¬°@-topgem

  util/¤U·s¼W³o¤ätopgemsize.c

  crontab -e³]­Ó©w´Á¶]ªº®É¶¡´N¥i¥H¤F¡C

  ¥t¥~³o¤äµ{¦¡¸Ì¦³­Ónode()¡A¸Ì­±ªº4094¸ò1024­Ó§O¬O§ÚªºµwºÐªì©l¤Æ®Éªºblock¸ò

  fragment¤j¤p¡A³o¥u¯àºâ¥X¤ñ¸û±µªñªºinode¼Æ(¤@­Óinode¦û¥h128 bytes)¡A¦pªG§Aªº

  ¤ñ¨Ò¤£¬O4096 / 1024½Ð½Õ¾ã¦¨¦Û¤vµwºÐªº°Ñ¼Æ¡C

: src/util/Makefile

EXE =   ... [1;33mtopgemsize[m

: topgemsize.c

/*-------------------------------------------------------*/
/* util/topgemsize.c    ( NTHU CS MapleBBS Ver 3.10 )    */
/*-------------------------------------------------------*/
/* target : ¬ÝªOºëµØ°Ï°Ï±Æ¦æº]                           */
/* create : 04/01/02                                     */
/* author : amaki.bbs@luna.twbbs.org                     */
/*-------------------------------------------------------*/


#include "bbs.h"

#define TOPGEM  "gem/@/@-topgem"

typedef struct
{
  int year;
  int yday;
  int mon;
  int mday;
  int wday;
  int hour;
} DATE;


typedef struct
{
  int bno;
  int dir_nums;
  int file_nums;
  int gsize;
} BGEM;


static BCACHE *bshm;
static BGEM *bgem;


static int
node(size)
  int size;
{
  int node, frag;

  node = (size / 4096) * 128;
  node += (frag = (size % 4096) / 1024) ? frag * 128 : 0;

  return node;
}


static void
gem_folder(folder, gem_set)
  char *folder;
  BGEM *gem_set;
{
  int fd, count, dnum;
  char fpath[64];
  HDR *xt, *hdr;
  struct stat st;

  if ((fd = open(folder, O_RDONLY)) < 0)
    return;

  fstat(fd, &st);
  hdr = xt = (HDR *) malloc(count = st.st_size);
  count = read(fd, xt, count) / sizeof(HDR);
  close(fd);

  do
  {
    hdr_fpath(fpath, folder, hdr);

    if (hdr->xmode & GEM_FOLDER)
    {
      gem_set->dir_nums++;
      if (dnum = rec_num(fpath, sizeof(HDR)) > 0)
      {
        gem_set->file_nums++;
        gem_set->gsize += dnum * sizeof(HDR) + node(dnum * sizeof(HDR));
        gem_folder(fpath, gem_set);
      }
    }
    else if (dashf(fpath))
    {
      stat(fpath, &st);
      gem_set->file_nums++;
      gem_set->gsize += st.st_size + node(st.st_size);
    }
  } while (++hdr < xt + count);

  free(xt);
}


static void
gem_counter(brd, gem_set)
  BRD *brd;
  BGEM *gem_set;
{
  int fd, count, dnum;
  char fpath[64], folder[64];
  HDR *xt, *hdr;
  struct stat st;

  sprintf(folder, "gem/brd/%s/%s", brd->brdname, FN_DIR);

  if ((fd = open(folder, O_RDONLY)) < 0)
    return;

  fstat(fd, &st);
  hdr = xt = (HDR *) malloc(count = st.st_size);
  count = read(fd, xt, count) / sizeof(HDR);
  close(fd);

  do
  {
    hdr_fpath(fpath, folder, hdr);

    if (hdr->xmode & GEM_FOLDER)
    {
      gem_set->dir_nums++;
      if (dnum = rec_num(fpath, sizeof(HDR)) > 0)
      {
        gem_set->file_nums++;
        gem_set->gsize += dnum * sizeof(HDR) + node(dnum * sizeof(HDR));
        gem_folder(fpath, gem_set);
      }
    }
    else if (dashf(fpath))
    {
      stat(fpath, &st);
      gem_set->file_nums++;
      gem_set->gsize += st.st_size + node(st.st_size);
    }
  } while (++hdr < xt + count);

  free(xt);
}


static void
gem_record(date)
  DATE *date;
{
  int ansi, i = 0;
  BRD *brd;
  BGEM *bgem_set;
  FILE *fp;
  char msg[80], dbuf[16], anony[16];

  if (!(fp = fopen(TOPGEM, "w")))
    return;

  sprintf(msg, "%d¤ë%d¤é¬ÝªOºëµØ°Ï±Æ¦æ", date->mon, date->mday);

  fprintf(fp, "\033[1;35;47m%*s%*s",
    41 + strlen(msg) / 2, msg, 41 - strlen(msg) / 2, "\033[m\n");
 fprintf(fp, "\033[1;37;45m¡i±Æ  ¦W¡j  ¡i¬Ý    ªO¡j  ¡iÀÉ®×¼Æ¡j  ¡i¥Ø¿ý¼Æ¡j"
   "  ¡iÁ`ºëµØ°Ï¤j¤p(bytes)¡j     \033[m\n");

  do
  {
    ansi = 0;
    bgem_set = bgem + i;
    brd = bshm->bcache + bgem_set->bno;
    sprintf(dbuf, "%d.", i + 1);
    sprintf(anony, "%c%s", brd->brdname[0], "¡³¡³¡³¡³");

    if (i < 5)
    {
      fprintf(fp, "  \033[1m%-11s%-14s%-12d%-12d%-d ", dbuf,
      (brd->battr & BRD_NOSTAT) ? anony : brd->brdname,
      bgem_set->file_nums, bgem_set->dir_nums, bgem_set->gsize);
      ansi = 1;
    }
    else if (i < 9)
    {
      fprintf(fp, "  \033[1;33m%-11s%-14s%-12d%-12d%-d ", dbuf,
      (brd->battr & BRD_NOSTAT) ? anony : brd->brdname,
      bgem_set->file_nums, bgem_set->dir_nums, bgem_set->gsize);
      ansi = 1;
    }
    else
    {
      fprintf(fp, "  %-11s%-14s%-12d%-12d%-d ", dbuf,
      (brd->battr & BRD_NOSTAT) ? anony : brd->brdname,
      bgem_set->file_nums, bgem_set->dir_nums, bgem_set->gsize);
    }

    if (bgem_set->gsize > 1048576)
      fprintf(fp, "(%dMB)%s\n", bgem_set->gsize / 1048576, ansi ? "\033[m":"");
    else if (bgem_set->gsize > 1024)
      fprintf(fp, "(%dKB)%s\n", bgem_set->gsize / 1024, ansi ? "\033[m" : "");
    else
      fprintf(fp, ansi ? "\033[m\n" : "\n");
  } while (++i < bshm->number);

  fclose(fp);
}


static int
bgem_cmp(a, b)
  BGEM *a, *b;
{
  return b->gsize - a->gsize;
}


int
main()
{
  int i;
  BRD *brd;
  DATE now;
  BGEM *gem_set;
  time_t time_now;
  struct tm *t;

  chdir(BBSHOME);

  bshm = shm_new(BRDSHM_KEY, sizeof(BCACHE));
  bgem = (BGEM *) malloc(sizeof(BGEM) * bshm->number);
  memset(bgem, 0, sizeof(BGEM) * bshm->number);

  time(&time_now);
  time_now -= 400;
  t = localtime(&time_now);
  now.year = t->tm_year;
  now.yday = t->tm_yday;
  now.mon = t->tm_mon + 1;
  now.mday = t->tm_mday;
  now.wday = t->tm_wday;
  now.hour = t->tm_hour;

  for (i = 0; i < bshm->number; i++)
  {
    brd = bshm->bcache + i;
    gem_set = bgem + i;
    /* amaki.030730: ¶}±Ò¬ÝªO¥Ø¿ý¤Uªºbdata */
    if (*brd->brdname)
    {
      gem_set->bno = i;
      gem_counter(brd, gem_set);
    }
  }

  qsort(bgem, bshm->number, sizeof(BGEM), bgem_cmp);

  gem_record(&now);

  free(bgem);
  return 0;
}

--
  [1;33mOrigin: luna.twbbs.org[m
